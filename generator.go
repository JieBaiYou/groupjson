package groupjson

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
)

// Generator 用于生成GroupJSON序列化代码
type Generator struct {
	// 代码生成的输入参数
	TypeName      string
	PackageName   string
	SourceFile    string
	OutputFile    string
	TagName       string
	StructComment string
}

// NewGenerator 创建一个新的代码生成器
func NewGenerator() *Generator {
	return &Generator{
		TagName: "groups", // 默认标签名
	}
}

// Generate 解析源文件并生成代码
func (g *Generator) Generate() error {
	// 如果未指定输出文件, 则使用默认命名
	if g.OutputFile == "" {
		dir := filepath.Dir(g.SourceFile)
		base := filepath.Base(g.SourceFile)
		g.OutputFile = filepath.Join(dir, strings.TrimSuffix(base, ".go")+"_groupjson.go")
	}

	// 解析源文件
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, g.SourceFile, nil, parser.ParseComments)
	if err != nil {
		return WrapError(err, "parse source file")
	}

	// 提取包名
	g.PackageName = f.Name.Name

	// 查找目标结构体定义
	structType, err := g.findStructType(f)
	if err != nil {
		return err
	}

	// 解析结构体字段和标签
	fields, err := g.parseStructFields(structType)
	if err != nil {
		return err
	}

	// 生成代码
	code, err := g.generateCode(fields)
	if err != nil {
		return err
	}

	// 格式化代码
	formattedCode, err := format.Source(code)
	if err != nil {
		// 如果格式化失败, 仍然保存未格式化的代码以供调试
		_ = os.WriteFile(g.OutputFile+".unformatted", code, 0o644)
		return WrapError(err, "format generated code")
	}

	// 写入输出文件
	err = os.WriteFile(g.OutputFile, formattedCode, 0o644)
	if err != nil {
		return WrapError(err, "write output file")
	}

	return nil
}

// findStructType 在AST中查找指定名称的结构体定义
func (g *Generator) findStructType(f *ast.File) (*ast.StructType, error) {
	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok || typeSpec.Name.Name != g.TypeName {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				return nil, fmt.Errorf("type %s is not a struct", g.TypeName)
			}

			// 提取结构体注释
			if genDecl.Doc != nil {
				g.StructComment = genDecl.Doc.Text()
			}

			return structType, nil
		}
	}

	return nil, fmt.Errorf("struct %s not found in %s", g.TypeName, g.SourceFile)
}

// 字段信息, 用于代码生成
type fieldInfo struct {
	Name      string
	JSONName  string
	Groups    []string
	OmitEmpty bool
	OmitZero  bool
}

// parseStructFields 解析结构体字段及其标签
func (g *Generator) parseStructFields(structType *ast.StructType) ([]fieldInfo, error) {
	var fields []fieldInfo

	for _, field := range structType.Fields.List {
		// 跳过未命名字段
		if len(field.Names) == 0 {
			continue
		}

		fieldName := field.Names[0].Name
		// 跳过未导出字段
		if !ast.IsExported(fieldName) {
			continue
		}

		// 无标签字段跳过
		if field.Tag == nil {
			continue
		}

		tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))

		// 解析json标签
		jsonTag := tag.Get("json")
		if jsonTag == "-" {
			continue
		}

		jsonOpts := strings.Split(jsonTag, ",")
		jsonName := fieldName
		if jsonOpts[0] != "" {
			jsonName = jsonOpts[0]
		}

		// 检查json选项
		omitEmpty := false
		omitZero := false
		for _, opt := range jsonOpts[1:] {
			if opt == "omitempty" {
				omitEmpty = true
			}
			if opt == "omitzero" {
				omitZero = true
			}
		}

		// 解析groups标签
		groupsTag := tag.Get(g.TagName)
		if groupsTag == "" {
			continue // 没有分组标签的字段不生成序列化代码
		}

		groups := strings.Split(groupsTag, ",")

		fields = append(fields, fieldInfo{
			Name:      fieldName,
			JSONName:  jsonName,
			Groups:    groups,
			OmitEmpty: omitEmpty,
			OmitZero:  omitZero,
		})
	}

	return fields, nil
}

// 代码生成模板
const codeTemplate = `// Code generated by groupjson; DO NOT EDIT.
// Source: {{ .SourceFile }}

package {{ .PackageName }}

import (
	"encoding/json"
	"github.com/JieBaiYou/groupjson"
)

{{ if .StructComment }}// {{ .TypeName }} {{ .StructComment }}{{ end }}

// MarshalWithGroups 将 {{ .TypeName }} 序列化为带有组过滤的JSON
func (v {{ .TypeName }}) MarshalWithGroups(groups ...string) ([]byte, error) {
	return v.MarshalWithGroupsOptions(groupjson.DefaultOptions(), groups...)
}

// MarshalWithGroupsOptions 将 {{ .TypeName }} 序列化为带有组过滤和自定义选项的JSON
func (v {{ .TypeName }}) MarshalWithGroupsOptions(opts groupjson.Options, groups ...string) ([]byte, error) {
	// 使用提供的组更新选项
	if len(groups) > 0 {
		opts.Groups = groups
	}

	// 如果没有指定组, 则返回空对象
	if len(opts.Groups) == 0 {
		if opts.TopLevelKey != "" {
			return []byte("{\"" + opts.TopLevelKey + "\":{}}"), nil
		}
		return []byte("{}"), nil
	}

	// 创建结果映射
	result := make(map[string]any)

	{{ range .Fields }}
	// 字段 {{ .Name }}
	{{ range .Groups }}
	if shouldIncludeGroup(opts, "{{ . }}") {
		{{ if .OmitEmpty }}
		// 处理omitempty
		if !isEmpty(v.{{ .Name }}) {
			result["{{ .JSONName }}"] = v.{{ .Name }}
		}
		{{ else if .OmitZero }}
		// 处理omitzero
		if !isZero(v.{{ .Name }}) {
			result["{{ .JSONName }}"] = v.{{ .Name }}
		}
		{{ else }}
		result["{{ .JSONName }}"] = v.{{ .Name }}
		{{ end }}
		break // 一旦添加了字段, 就不需要检查其他组
	}
	{{ end }}
	{{ end }}

	// 应用顶层包装键
	if opts.TopLevelKey != "" {
		wrapper := make(map[string]any)
		wrapper[opts.TopLevelKey] = result
		return json.Marshal(wrapper)
	}

	return json.Marshal(result)
}

// 辅助函数

// shouldIncludeGroup 根据选项确定是否应包含组
func shouldIncludeGroup(opts groupjson.Options, group string) bool {
	if opts.GroupMode == groupjson.ModeAnd {
		// AND模式：检查组是否在所有需要的组中
		for _, g := range opts.Groups {
			if g == group {
				return true
			}
		}
		return false
	} else {
		// OR模式：检查组是否在任何需要的组中
		for _, g := range opts.Groups {
			if g == group {
				return true
			}
		}
		return false
	}
}

{{ if .HasOmitEmpty }}
// isEmpty 检查值是否为空（用于omitempty）
func isEmpty(v any) bool {
	switch v := v.(type) {
	case nil:
		return true
	case string:
		return v == ""
	case bool:
		return !v
	case int, int8, int16, int32, int64:
		return v == 0
	case uint, uint8, uint16, uint32, uint64, uintptr:
		return v == 0
	case float32, float64:
		return v == 0
	case []any:
		return len(v) == 0
	case map[string]any:
		return len(v) == 0
	}
	return false
}
{{ end }}

{{ if .HasOmitZero }}
// isZero 检查值是否为零值（用于omitzero）
func isZero(v any) bool {
	switch v := v.(type) {
	case nil:
		return true
	case string:
		return v == ""
	case bool:
		return !v
	case int, int8, int16, int32, int64:
		return v == 0
	case uint, uint8, uint16, uint32, uint64, uintptr:
		return v == 0
	case float32, float64:
		return v == 0
	}
	return false
}
{{ end }}
`

// 模板数据
type templateData struct {
	PackageName   string
	TypeName      string
	SourceFile    string
	Fields        []fieldInfo
	HasOmitEmpty  bool
	HasOmitZero   bool
	StructComment string
}

// generateCode 使用模板生成代码
func (g *Generator) generateCode(fields []fieldInfo) ([]byte, error) {
	// 检查是否有字段使用omitempty或omitzero
	hasOmitEmpty := false
	hasOmitZero := false
	for _, field := range fields {
		if field.OmitEmpty {
			hasOmitEmpty = true
		}
		if field.OmitZero {
			hasOmitZero = true
		}
	}

	// 准备模板数据
	data := templateData{
		PackageName:   g.PackageName,
		TypeName:      g.TypeName,
		SourceFile:    filepath.Base(g.SourceFile),
		Fields:        fields,
		HasOmitEmpty:  hasOmitEmpty,
		HasOmitZero:   hasOmitZero,
		StructComment: strings.TrimSpace(g.StructComment),
	}

	// 解析模板
	tmpl, err := template.New("generator").Parse(codeTemplate)
	if err != nil {
		return nil, WrapError(err, "parse template")
	}

	// 执行模板
	var buf bytes.Buffer
	err = tmpl.Execute(&buf, data)
	if err != nil {
		return nil, WrapError(err, "execute template")
	}

	return buf.Bytes(), nil
}
